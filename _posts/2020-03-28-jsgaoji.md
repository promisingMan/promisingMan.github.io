---
layout:     post
title:      "js之词法作用域和动态作用域"
subtitle:   " \"每天积累一点之词法作用域，动态作用域学习\""
date:       2020-03-28 12:08:24
author:     "ZH"
header-img: "img/home-bg-art.jpg"
catalog: true
tags:
    - JS
---

## 词法作用域
简单来说，词法作用域就是定义在词法阶段的作用域，是写代码时就已经确定好的，因此当词法分析处理代码时会保持作用于不变

### 关系

无论函数在哪调用，也无论它怎么被调用，它的词法作用域都只有函数被声明所处的位置决定

```
function foo(a) {
    var b = a * 2;
    function bar(c) {
        console.log( a, b, c );
    }
    bar(b * 3);
}
foo( 2 ); // 2 4 12
```
在这个例子中有三个逐级嵌套的作用域。为了帮助理解，可以将它们想象成几个逐级包含的气泡
![avatar](/img/js.cf.webp)
作用域气泡由其对应的作用域块代码写在哪里决定的，它们是逐级包含的。
- 气泡1包含着整个全局作用域，其中只有一个标识符:foo
- 气泡2包含着foo创建的作用域，其中有三个标识符: a,b,bar
- 气泡3包含着bar创建的作用域，其中有一个标识符c

### 查找
作用域气泡的结构和互相之间的位置关系给引擎提供了足够的位置信息，引擎用这些信息来查找标识符的位置   
在代码片段中，引擎执行console.log(...)声明，并查找a,b,c三个变量。首先从最内部的bar作用域开始找起，在这里无法找到a，就会去上一级也就是foo的作用域开始查找，类比之下对b,c执行相同的操作

<font color=orange>注意:</font> 词法作用域只会查找一级标识符，比如你使用foo.bar.baz,词法作用域查找只会试图查找foo标识符，找到这个变量后，对象属性访问规则分别接管对bar和baz属性的访问

```
foo = {
    bar:{
        baz: 1
    }
};
console.log(foo.bar.baz);//1
```

### 遮蔽
作用域查找从运行所处最内部作用域开始，逐级向上进行，当遇见第一个匹配即停止
在多层的嵌套作用域中可以定义同名的标识符，这叫做"遮蔽效应"，内部标识符"遮蔽"了外部的标识符

```
var a = 0;
function test(){
    var a = 1;
    console.log(a);//1
}
test();
```
在这个例子里，内部a就遮蔽了外部a的引用
如果我们想要对其访问

```
var a = 0;
function test(){
    var a = 1;
    console.log(window.a);//0
}
test();
```
这种方法只适用于是全局对象，如果非全局对象被遮蔽了，是无论如何都无法访问到的

## 动态作用域
在js里使用的是词法作用域，最重要的特征便是它的定义过程发生在代码书写阶段   

既然没有为什么还要介绍动态作用域呢，是因为在js里this一定程度上起了动态作用域的作用   

动态作用域并不关心函数和作用域是如何声明以及在如何处声明的，只关心它们从何处调用。换言之，作用域是基于调用栈的，而不是基于作用域嵌套   
来看一段代码

```
var a = 2;
function foo() {
    console.log( a );
}
function bar() {
    var a = 3;
    foo();
}
bar();
```
- 按词法作用域来分析的话，打印出来a,调用bar，去找foo作用域没找到a那么变回往上面查询即就是全局作用域找到便停止查询，打印2

- 按动态作用域来分析，记住动态作用域只关心是从何处调用，一样的流程在foo查找没找到a，它不会往上级查找，而是回到调用它的地方去查找，既打印3

两种作用域区别，简而言之，词法作用域是在定义确定的，而动态作用域是在运行时确定的